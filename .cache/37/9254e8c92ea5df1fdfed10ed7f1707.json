{"id":"XFML","dependencies":[{"name":"/home/i6apxat/htdocs/ol6/package.json","includedInParent":true,"mtime":1679700623179},{"name":"/home/i6apxat/htdocs/ol6/node_modules/geotiff/package.json","includedInParent":true,"mtime":1679700660922}],"generated":{"js":"var $XFML$exports={};function $XFML$var$decodeRowAcc(r,e){var o=r.length-e,t=0;do{for(var a=e;a>0;a--)r[t+e]+=r[t],t++;o-=e}while(o>0)}function $XFML$var$decodeRowFloatingPoint(r,e,o){for(var t=0,a=r.length,n=a/o;a>e;){for(var i=e;i>0;--i)r[t+e]+=r[t],++t;a-=e}for(var c=r.slice(),d=0;d<n;++d)for(var l=0;l<o;++l)r[o*d+l]=c[(o-l-1)*n+d]}function $XFML$export$applyPredictor(r,e,o,t,a,n){if(!e||1===e)return r;for(var i=0;i<a.length;++i){if(a[i]%8!=0)throw new Error(\"When decoding with predictor, only multiple of 8 bits are supported.\");if(a[i]!==a[0])throw new Error(\"When decoding with predictor, all samples must have the same size.\")}for(var c=a[0]/8,d=2===n?1:a.length,l=0;l<t&&!(l*d*o*c>=r.byteLength);++l){var $=void 0;if(2===e){switch(a[0]){case 8:$=new Uint8Array(r,l*d*o*c,d*o*c);break;case 16:$=new Uint16Array(r,l*d*o*c,d*o*c/2);break;case 32:$=new Uint32Array(r,l*d*o*c,d*o*c/4);break;default:throw new Error(\"Predictor 2 not allowed with \".concat(a[0],\" bits per sample.\"))}$XFML$var$decodeRowAcc($,d,c)}else 3===e&&$XFML$var$decodeRowFloatingPoint($=new Uint8Array(r,l*d*o*c,d*o*c),d,c)}return r}$XFML$exports.applyPredictor=$XFML$export$applyPredictor;"},"sourceMaps":null,"error":null,"hash":"a2c7220663f7c6ebc0338bc69f99fd97","cacheData":{"env":{},"imports":{},"exports":{"applyPredictor":"$XFML$export$applyPredictor"},"wildcards":[],"sideEffects":false,"isES6Module":true}}